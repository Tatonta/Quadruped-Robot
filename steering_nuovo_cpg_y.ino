#include <BasicLinearAlgebra.h>

#include <Math.h>
#include <SoftwareSerial.h>
#include <Dynamixel_Serial.h> // Library that allows the control of the servo motors
#define dt 0.05 // integration step by using the Euler method 
#define L_size 8 // Dimension of the Laplacian Matrice (8x8) 
//#define OFFSET_SPALLA 285*1.5 // Shoulder that oscillates with an angle of 25°*1.5 
//#define OFFSET_GOMITO 341*2 // Elbow that oscillates with an angle of 30°*2 
int OFFSET_SPALLA = 285*2;
int OFFSET_GOMITO = 200;
#define N_CAMP 10 // Number of samples to be discarded 
#define GAIT 1
#define N_Legs 4 // Number of the legs of the robot 
 
// Definition of the Dynamixel interfaces 
DynamixelClass L1; 
DynamixelClass R1; 
DynamixelClass L2; 
DynamixelClass R2; 
DynamixelClass Legs[N_Legs] = {L1,R1,L2,R2}; 
 
// SoftwareSerial pins 
#define SOFT_TX_PIN_L1 8 
#define SOFT_TX_PIN_R1 9 
#define SOFT_TX_PIN_L2 10 
#define SOFT_TX_PIN_R2 11 
 
// Definition of the SerialSoftware (RX,TX) 
SoftwareSerial mySerial[N_Legs] ={SoftwareSerial(0,SOFT_TX_PIN_L1), 
SoftwareSerial(0,SOFT_TX_PIN_R1), 
SoftwareSerial(0,SOFT_TX_PIN_L2), 
SoftwareSerial(0,SOFT_TX_PIN_R2)}; 

// Motors ID (they must be sequential) 
#define ID_SPALLA 1 
#define ID_GOMITO 2
 
// Rotation speed of the servo motors [0,4095] 
int16_t speed = 0xFFF; 
int AS[4]={0,0,0,0}; 
int AG[4]={0,0,0,0}; 
int h,l; 
 
// Baudrate speed of communication 
const long unsigned int motor_baudrate = 100000; 

// Matrices for the CPG calculation 
Matrice<1, L_size> x_p, y_p, f, ones; 
Matrice<L_size, L_size> L; 

// Shoulder -> angoli[0] , Elbow -> angoli[1] 
float angoli[4][2]; 
 
//Default positions(bent limbs) 
int SPALLA_START_POSITION[] = {1551,1559,1446,1550}; 
int GOMITO_START_POSITION[] = {1124,1124,1024,1124};


//Equal positions 
//int SPALLA_START_POSITION[] = {2120,2120,2120,2120}; 
//int GOMITO_START_POSITION[] = {2048,2048,2048,2048}; 
 
 
// Laplacian Matrice for the slow walking gait 
float Ls[L_size][L_size] = { 
{3, 0, 0, -1, 0, 1, 1, 0,}, 
{0, 3, 1, 0, -1, 0, 0, 1,}, 
{0, 1, 3, 0, 1, 0, 0, -1,}, 
{ -1, 0, 0, 3, 0, 1, 1, 0,}, 
{0, -1, 1, 0, 3, 0, 0, 1,}, 
{1, 0, 0, 1, 0, 3, -1, 0,}, 
{1, 0, 0, 1, 0, -1, 3, 0,}, 
{0, 1, -1, 0, 1, 0, 0, 3,} 
 }; 
 
// Laplacian Matrice for the trot gait 
float Lt[L_size][L_size] = { 
{3,0,1,0,1,0,-1,0,}, 
{0,3,0,1,0,1,0,-1,}, 
{1,0,3,0,-1,0,1,0,}, 
{0,1,0,3,0,-1,0,1,}, 
{1,0,-1,0,3,0,1,0,}, 
{0,1,0,-1,0,3,0,1,}, 
{-1,0,1,0,1,0,3,0,}, 
{0,-1,0,1,0,1,0,3,} 
}; 
// Laplacian Matrice for the gallop gait 
float Lg[L_size][L_size] = { 
{3.00,0.00,-0.81,-0.59,1.00,-0.00,0.81,0.59,}, 
{0.00,3.00,0.59,-0.81,0.00,1.00,-0.59,0.81,}, 
{-0.81,0.59,3.00,0.00,0.81,-0.59,1.00,-0.00,}, 
{-0.59,-0.81,0.00,3.00,0.59,0.81,0.00,1.00,}, 
{1.00,0.00,0.81,0.59,3.00,0.00,-0.81,-0.59,}, 
{-0.00,1.00,-0.59,0.81,0.00,3.00,0.59,-0.81,}, 
{0.81,-0.59,1.00,0.00,-0.81,0.59,3.00,0.00,}, 
{0.59,0.81,-0.00,1.00,-0.59,-0.81,0.00,3.00,} 
 
}; 
 
//Matlab code 
float eq1(float x, float y1, float y2,int s) { 
/* Matlab code
function z = eq1(x,y)
 z = -x(1)+1.7*y(1)-y(2);
 */ 
float z = -x + 1.7 * y1 - s*y2-0.3; 
return z; 
} 
 
float eq2(float x, float y1, float y2, int s) { 
/* Matlab code
function z = eq2(x,y)
z = -x(2)+1.7*y(2)+y(1);
*/ 
float z = -x + 1.7 * y2 + s*y1+0.3; 
return z; 
} 
 
Matrice<1, L_size> func(Matrice<1, L_size> f, Matrice<1, L_size> x) { 
 /* Matlab code
 function z = func(f,x,L)
 z = f.' - 3*L*(x.');
*/ 
float k = 3; 
Matrice<L_size,1> z; 
z = ~f - (L * (~x)) * k; 
return ~z; // Matrice<1,8> 
} 
 
// Conversion for the angles generated by the CPG into angles for the Dynamixel 
//se metto valori alti a SX allora vado a SX??????????
void raw_angles(int i,float x) {

//Serial.println("raw function"); 

//convergenza-->direzione dritta
 if(i==3 || i==1){
  OFFSET_GOMITO=250;
  OFFSET_SPALLA=285*2*1.2;
  
 }else{
  OFFSET_GOMITO=200;
  OFFSET_SPALLA=285*2;
 }
 
 
angoli[i][0] = SPALLA_START_POSITION[i] + x * OFFSET_SPALLA; 
angoli[i][1] = GOMITO_START_POSITION[i] + x * OFFSET_GOMITO; 
} 


 // temporary Matrices using to store the next state 
Matrice<1, L_size> x_temp, y_temp; 
// Matrice Laplacian used for the gait 
void setLaplacian(int val){ 
switch (val){ 
case 1: 
L = Ls; 
break; 
case 2: 
L = Lt; 
break; 
case 3: 
L = Lg; 
break; 
} 
} 
void setup() 
{ 
Serial.begin(9600); 
// CPG setup 
setLaplacian(GAIT); 
x_p.Init(); 
y_p.Init(); 
f.Fill(0); 
ones.Fill(1); 
// Serials setup 
for(int i=0;i<N_Legs;i++){ 
mySerial[i].begin(motor_baudrate); 
Legs[i].begin(mySerial[i]); 
} 

for(int i=0; i<4;i++){ 
Legs[i].setMode(ID_SPALLA,SERVO,0x000,speed); 
Legs[i].setMode(ID_GOMITO,SERVO,0x000,speed); 
} 
 
// Servo motors initialization 
for(int i=0; i<4;i++){ 
Legs[i].setMaxTorque(ID_SPALLA, 0x2FF); 
Legs[i].setBaudRate(ID_SPALLA,motor_baudrate);
Legs[i].setMaxTorque(ID_GOMITO, 0x2FF); 
Legs[i].setBaudRate(ID_GOMITO,motor_baudrate); 
 } 

// Serial.println("Made Setup"); 
delay(1000); 
//Serial.println("Get up"); 
int x; 
for(int i=0; i<4;i++){ 
if(i==0 || i==2){ 
x=1; 
}
 else{ 
 x=-1; 
 } 
 Legs[i].servo(ID_SPALLA,SPALLA_START_POSITION[i]*x,0x100); 
 Legs[i].servo(ID_GOMITO,GOMITO_START_POSITION[i]*x,0x100); 
 } 
 delay(5000); 
 } 

float y_temp_1;
float y_temp_2;
float y_temp_3;
float y_temp_4;
float y_temp_5;
float y_temp_6;
float y_temp_7;
float y_temp_8;
int s;

 void loop() { 
 int x; 
 int start_time = millis();



 //N_CAMP di samples scartati
 for(int i=0; i<N_CAMP; i++){ 
   y_temp_1= (abs(float(x_p(0,0)) + 1) - abs(float(x_p(0,0)) - 1)) * 0.5;
   y_temp_2= (abs(float(x_p(0,1)) + 1) - abs(float(x_p(0,1)) - 1)) * 0.5;
   y_temp_3= (abs(float(x_p(0,2)) + 1) - abs(float(x_p(0,2)) - 1)) * 1;
   y_temp_4= (abs(float(x_p(0,3)) + 1) - abs(float(x_p(0,3)) - 1)) * 1;
   y_temp_5= (abs(float(x_p(0,4)) + 1) - abs(float(x_p(0,4)) - 1)) * 0.5;
   y_temp_6= (abs(float(x_p(0,5)) + 1) - abs(float(x_p(0,5)) - 1)) * 0.5;
   y_temp_7= (abs(float(x_p(0,6)) + 1) - abs(float(x_p(0,6)) - 1)) * 1;
   y_temp_8= (abs(float(x_p(0,7)) + 1) - abs(float(x_p(0,7)) - 1)) * 1;


  float y_p_c[1][8] = {{y_temp_1,y_temp_2,y_temp_3,y_temp_4,y_temp_5,y_temp_6,y_temp_7,y_temp_8}};
  Matrice<1,8> y_temp(y_p_c);
  y_p = y_temp; 

 // Dynamics of the system -> f(x,t) 
 for (int j = 0; j < L_size; j += 2) { 

  //MODIFICA SU PARAMETRO "s"
   if(j==0 || j==4){
     s=0.71;
   }else{
       s=2.5;
   }
  f(0, j) = eq1(x_p(0, j), y_p(0, j), y_p(0, j + 1),s); 
  f(0, j + 1) = eq2(x_p(0, j + 1), y_p(0, j), y_p(0, j + 1),s);
 } 

  x_temp = x_p + (func(f, x_p)) * dt;
  x_p = x_temp; 

} 

 // conversion of the generated angle in raw 
 // controllo attraverso output
  for(int j=0;j<4;j=j+1){ 
    raw_angles(j,y_p(0,j*2)); 
  } 
 
 

for(int i=0; i<4;i=i+1){ 
int v[4]={1,-1,1,-1};
Legs[i].servo(ID_SPALLA,angoli[i][0]*v[i],0x090); 
Legs[i].servo(ID_GOMITO,angoli[i][1]*v[i],0x090); 

// robot gait frequency 
delay(1); 
 
} 
}  
